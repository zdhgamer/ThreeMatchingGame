---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zdh.
--- DateTime: 2018/11/11 21:01
---

require("Logic/LLuaComponent")
require("Logic/GameItem")
require("Common/eventids")
local Event = require("events")
require("EventDispatcher")

local colorOne = 0
local colorTwo = 1
local colorThree = 2
local colorFour = 3

GameLogic = {
    componentName = "",
    ---@type UnityEngine.GameObject
    gameObject = nil,
    ItemBgs = nil,
    ColorOne = nil,
    ColorTwo = nil,
    ColorThree = nil,
    ColorFour = nil,
    ColorFive = nil,
    ColorSix = nil,
    ColorSeven = nil,
    ColorItemSourceArray = nil,
    GameItemBgArray = nil,
    GameItemArray = nil,

    LastClickOne,
    NextClickOne,
}

GameLogic.__index = GameLogic

setmetatable(GameLogic, LLuaComponent)

---@param gameObject UnityEngine.GameObject
function GameLogic:New(componentName, gameObject)
    local result = {}
    result = LLuaComponent:New(componentName, gameObject)
    setmetatable(result, GameLogic)
    result.componentName = componentName
    result.gameObject = gameObject
    result.self = result
    return result
end

function GameLogic:Awake()
    log("触发继承的Awake")
    EventDispatcher:AddEventListener(EventIds.ItemClicked, function(itemCom)
        self:OnGameItemClick(itemCom)
    end)
    log(self.componentName)
    log(self.gameObject.name)
    self.ItemBgs = self.gameObject.transform:Find('ItemBgs');
    resMgr:LoadPrefab("gameprefabs", { 'BgItem' }, function(objs)
        self:InitBgItems(objs)
    end)

end

function GameLogic:InitBgItems(objs)
    log(objs[0].name)
    self.GameItemBgArray = {}
    for x = -4, 4, 1 do
        self.GameItemBgArray[x] = {}
        for y = 4, -4, -1 do
            ---@type UnityEngine.GameObject
            local item = newObject(objs[0])
            item.transform.parent = self.ItemBgs
            item.name = x .. y .. ''
            item.transform.position = Vector3(x, y, 0)
            self.GameItemBgArray[x][y] = item
        end
    end
    resMgr:LoadPrefab("gameprefabs", { "ColorOne", "ColorTwo", "ColorThree",
                                       "ColorFour", "ColorFive", "ColorSix", "ColorSeven" }, function(objs1)
        self.ColorOne = objs1[0]
        self.ColorTwo = objs1[1]
        self.ColorThree = objs1[2]
        self.ColorFour = objs1[3]
        self.ColorFive = objs1[4]
        self.ColorSix = objs1[5]
        self.ColorSeven = objs1[6]
        self.ColorItemSourceArray = {}
        for i = 0, 6 do
            self.ColorItemSourceArray[i + 1] = objs1[i]
        end
        self:InitGameItem()
    end)
    log(self.componentName)
end

--初始化游戏小方块
function GameLogic:InitGameItem()
    math.randomseed(os.time())
    self.GameItemArray = {}
    for x = -4, 4, 1 do
        self.GameItemArray[x] = {}
        for y = 4, -4, -1 do
            local colorIndex = math.random(1, 6)
            ---@type UnityEngine.GameObject
            local item = newObject(self.ColorItemSourceArray[colorIndex])
            item.transform.parent = self.GameItemBgArray[x][y].transform
            item.name = x .. y .. colorIndex
            item.transform.localScale = Vector3(1, 1, 1)
            item.transform.localPosition = Vector3(0, 0, 0)
            local itemCom = GameItem:New('GameItem', item)
            itemCom.x = x
            itemCom.y = y
            itemCom.colorIndex = colorIndex
            local itemCCom = LuaComponent.AddLuaComponent(item, itemCom)
            self.GameItemArray[x][y] = itemCom
        end
    end
    local dead = self:CheckIsDeadMap()
    if dead then
        self:ClearGameItems()
        self:InitGameItem()
    end
    self:DoClear()

end

--执行消除，下落，填充操作
function GameLogic:DoClear()
    local canDis = self:GetCanClearItems()
    local total = self:GetTotal(canDis)
    self:ClearDisGameItem(canDis)
    self:DownToFit(function()
        log('+++++++++++++++++++++++++++++++++++++++++++++++++')
        self:InstantiateDownGameItem(total, function()
            log('cccccccccccccccbbbbbbbbbbb')
            canDis = self:GetCanClearItems()
            log('------------------------------------' .. tostring(#canDis))
            log(self.gameObject.name)
            if #canDis > 0 then
                self:DoClear()
            end
        end)
    end)
end


--获取二维数组的总大小
function GameLogic:GetTotal(target)
    local temp = {}
    for key1, value1 in ipairs(target) do
        for key2, value2 in ipairs(value1) do
            local contain = false
            for i = 1, #temp do
                if temp[i].gameObject.name == value2.gameObject.name then
                    contain = true
                end
            end

            if not contain then
                temp[#temp + 1] = value2
            end
        end
    end

    return #temp
end

--生成新的游戏item，然后使之下落
function GameLogic:InstantiateDownGameItem(total, callback)
    math.randomseed(os.time())
    local temp = { count = 0 }
    for x = -4, 4, 1 do
        coroutine.start(self.NewNewGameItem, self, temp, total, x, callback)
    end
end

--生成新得到item
function GameLogic:NewNewGameItem(tempCount, total, x, callback)
    for y = -4, 4, 1 do
        if self.GameItemArray[x][y] == nil then
            local colorIndex = math.random(1, 6)
            ---@type UnityEngine.GameObject
            local item = newObject(self.ColorItemSourceArray[colorIndex])
            item.transform.parent = self.GameItemBgArray[x][y].transform
            item.name = x .. y .. colorIndex
            item.transform.localScale = Vector3(1, 1, 1)
            item.transform.position = Vector3(x, 5, 0)
            local itemCom = GameItem:New('GameItem', item)
            itemCom.x = x
            itemCom.y = y
            local length = 5 - itemCom.y
            itemCom.colorIndex = colorIndex
            local itemCCom = LuaComponent.AddLuaComponent(item, itemCom)
            self.GameItemArray[x][y] = itemCom
            itemCom:MoveTo(x, y, function()
                tempCount.count = tempCount.count + 1
                log('countcountcountcountcountcount' .. tostring(tempCount.count))
                log('totaltotaltotaltotaltotaltotaltotaltotal' .. tostring(total))
                if tempCount.count >= total then
                    if callback ~= nil then
                        callback()
                    end
                end
            end, length)
        end
        coroutine.wait(0.25)
    end
end

--消除之后，使悬空的所有item，下落到合适的位置上面去
function GameLogic:DownToFit(callback)
    local calledCount = 0
    local count = 0
    for x = -4, 4, 1 do
        for y = -4, 4, 1 do
            --需要这一个是nil的格子，上面的才能往下面落
            if self.GameItemArray[x][y] == nil then
                for yy = y + 1, 4, 1 do
                    if self.GameItemArray[x][yy] ~= nil then
                        count = count + 1
                        local length = yy - y
                        ---@type GameItem
                        self.GameItemArray[x][y] = self.GameItemArray[x][yy]
                        self.GameItemArray[x][yy] = nil
                        self.GameItemArray[x][y].x = x
                        self.GameItemArray[x][y].y = y
                        self.GameItemArray[x][y].gameObject.name = x .. y .. self.GameItemArray[x][y].colorIndex
                        self.GameItemArray[x][y]:MoveTo(x, y, function()
                            self.GameItemArray[x][y].gameObject.transform.parent = self.GameItemBgArray[x][y].gameObject.transform
                            self.GameItemArray[x][y].gameObject.transform.localPosition = Vector3(0, 0, 0)
                            calledCount = calledCount + 1
                            if calledCount >= count and callback ~= nil then
                                callback()
                            end
                        end, length)
                        break
                    end
                end
            end
        end
    end
    if count == 0 and callback ~= nil then
        callback()
    end
end

--清楚集合中的可以消除的数据
function GameLogic:ClearDisGameItem(total)
    for key, value in ipairs(total) do
        for ii, vv in ipairs(value) do
            self.GameItemArray[vv.x][vv.y] = nil
            destroy(vv.gameObject)
        end
    end
end

function GameLogic:ClearBgItems()
    for x = -4, 4, 1 do
        for y = 4, -4, -1 do
            destroy(self.GameItemBgArray[x][y])
            self.GameItemBgArray[x][y] = nil
        end
    end
    self.GameItemBgArray = {}
end

function GameLogic:ClearGameItems()
    for x = -4, 4, 1 do
        for y = 4, -4, -1 do
            destroy(self.GameItemArray[x][y].gameObject)
            self.GameItemArray[x][y] = nil
        end
    end
    self.GameItemArray = {}
end

--点击小方块，接受到的事件
---@param itemCom GameItem
function GameLogic:OnGameItemClick(itemCom)
    log(itemCom.x .. itemCom.y .. '被点击')
    log(self.gameObject.name)

    --第一次点击赋值
    if self.LastClickOne == nil then
        self.LastClickOne = itemCom
    end

    --第二次点击
    if self.LastClickOne ~= nil then
        --点击到同一个
        if itemCom.x == self.LastClickOne.x and itemCom.y == self.LastClickOne.y then
            self.LastClickOne = itemCom
        elseif self:CheckIsCanExchange(itemCom, self.LastClickOne) then
            --点击的是周围的其他一个，这时候需要交换位置，然后判定消除
            local canDis = self:GetTwoItemExChangCanDIsGroup(itemCom, self.LastClickOne)
            if #canDis > 0 then
                --可以消除
                self.NextClickOne = itemCom
                self:ExchangTwoGameItem(self.LastClickOne, itemCom)
                self.LastClickOne = nil
                self.NextClickOne = nil
            else
                self.LastClickOne = nil
                self.NextClickOne = nil
            end
        else
            --点到不是周围的那一个
            self.LastClickOne = itemCom
        end
    end

end

--交换两个的位置和父节点
---@param itemOne GameItem
---@param itemTwo GameItem
function GameLogic:ExchangTwoGameItem(itemOne, itemTwo)

    self.LastClickOne = nil
    self.NextClickOne = nil

    local oneParent = itemOne.gameObject.transform.parent
    local twoParent = itemTwo.gameObject.transform.parent

    local itemOneX = itemOne.x
    local itemOneY = itemOne.y

    local itemTwoX = itemTwo.x
    local itemTwoY = itemTwo.y

    self.GameItemArray[itemOneX][itemOneY], self.GameItemArray[itemTwoX][itemTwoY] = itemTwo, itemOne

    itemOne:MoveTo(itemTwo.x, itemTwo.y, function()
        itemOne.gameObject.transform.parent = twoParent
        itemOne.gameObject.transform.localPosition = Vector3(0, 0, 0)
        itemOne.x = itemTwoX
        itemOne.y = itemTwoY
        itemOne.gameObject.name = itemTwoX .. itemTwoY .. itemOne.colorIndex
    end)

    itemTwo:MoveTo(itemOne.x, itemOne.y, function()
        itemTwo.gameObject.transform.parent = oneParent
        itemTwo.gameObject.transform.localPosition = Vector3(0, 0, 0)
        itemTwo.x = itemOneX
        itemTwo.y = itemOneY
        itemTwo.gameObject.name = itemOneX .. itemOneY .. itemTwo.colorIndex
        self:DoClear()
    end)
end

--判断两个item是否可以交换
function GameLogic:CheckIsCanExchange(itemOne, itemTwo)
    local result = false

    if itemOne.x == itemTwo.x and itemOne.y == itemTwo.y then
        return result
    end

    if itemOne.colorIndex == itemTwo.colorIndex then
        return result
    end

    if math.abs(itemOne.x - itemTwo.x) <= 1 and math.abs(itemOne.y - itemTwo.y) <= 1 then
        if math.abs(itemOne.x - itemTwo.x) <= 1 and math.abs(itemOne.y - itemTwo.y) <= 0 then
            result = true
        end
        if math.abs(itemOne.x - itemTwo.x) <= 0 and math.abs(itemOne.y - itemTwo.y) <= 1 then
            result = true
        end
    end

    return result
end

--收集两个交换之后的可以消除的结果
function GameLogic:GetTwoItemExChangCanDIsGroup(itemOne, itemTwo)

    local result = {}

    local oneColorIndex = itemOne.colorIndex
    local twoColorIndex = itemTwo.colorIndex

    itemOne.colorIndex = twoColorIndex
    itemTwo.colorIndex = oneColorIndex

    --交换之后的可消除一行
    local oneRow = {}
    self:GetItemRows(oneRow, itemOne)
    --交换之后的可消除一列
    local oneCol = {}
    self:GetItemCols(oneCol, itemOne)

    local twoRow = {}
    self:GetItemRows(twoRow, itemTwo)

    local twoCol = {}
    self:GetItemCols(twoCol, itemTwo)

    if #oneRow >= 3 then
        result[#result + 1] = oneRow
    end

    if #oneCol >= 3 then
        result[#result + 1] = oneCol
    end

    if #twoRow >= 3 then
        result[#result + 1] = twoRow
    end

    if #twoCol >= 3 then
        result[#result + 1] = twoCol
    end

    itemOne.colorIndex = oneColorIndex
    itemTwo.colorIndex = twoColorIndex

    return result

end

--收集可以被消除的items{}
function GameLogic:GetCanClearItems()
    local result = {}

    for x = -4, 4, 1 do
        for y = 4, -4, -1 do
            local tempCol = {}
            if self.GameItemArray[x] ~= nil and self.GameItemArray[x][y] ~= nil then
                self:GetItemCols(tempCol, self.GameItemArray[x][y])
                if #tempCol >= 3 then
                    if self:CanContain(result, tempCol) then
                        result[#result + 1] = tempCol
                    end
                end
            end

            local tempRow = {}
            if self.GameItemArray[x] ~= nil and self.GameItemArray[x][y] ~= nil then
                self:GetItemRows(tempRow, self.GameItemArray[x][y])
                if #tempRow >= 3 then
                    if self:CanContain(result, tempRow) then
                        result[#result + 1] = tempRow
                    end
                end
            end
        end
    end

    return result

end

--判断是否可以被加入进来 true 是可以被加入 false是已经包含了
function GameLogic:CanContain(total, target)
    result = true
    for i, v in ipairs(total) do
        if #v == #target then
            local count = 0
            for k = 1, #v do
                for p = 1, #v do
                    if v[k].gameObject.name == target[p].gameObject.name then
                        count = count + 1
                    end
                end
            end
            if count == #target then
                result = false
            end
        end
    end

    return result
end

--获取这这一列相邻且颜色相同的集合
function GameLogic:GetItemCols(result, itemCom)
    result[#result + 1] = itemCom
    self:GetItemColUp(result, itemCom)
    self:GetItemColDown(result, itemCom)
    return result
end

--一列向上
function GameLogic:GetItemColUp(result, itemCom)
    if itemCom ~= nil then
        local nextX = itemCom.x
        local nextY = itemCom.y + 1

        if self.GameItemArray[itemCom.x] ~= nil and self.GameItemArray[nextX][nextY] ~= nil and self.GameItemArray[nextX][nextY].colorIndex == itemCom.colorIndex then
            result[#result + 1] = self.GameItemArray[nextX][nextY]
            self:GetItemColUp(result, self.GameItemArray[nextX][nextY])
        end
    end
end

--一列向下
function GameLogic:GetItemColDown(result, itemCom)
    if itemCom ~= nil then
        local nextX = itemCom.x
        local nextY = itemCom.y - 1
        if self.GameItemArray[itemCom.x] ~= nil and self.GameItemArray[nextX][nextY] ~= nil and self.GameItemArray[nextX][nextY].colorIndex == itemCom.colorIndex then
            result[#result + 1] = self.GameItemArray[nextX][nextY]
            self:GetItemColDown(result, self.GameItemArray[nextX][nextY])
        end
    end
end

--获取这一行且相邻颜色相同的
function GameLogic:GetItemRows(result, itemCom)
    result[#result + 1] = itemCom
    self:GetItemRowsRight(result, itemCom)
    self:GetItemRowsLeft(result, itemCom)
    return result
end

--一行向左
function GameLogic:GetItemRowsLeft(result, itemCom)
    if itemCom ~= nil then
        if self.GameItemArray[itemCom.x - 1] ~= nil and self.GameItemArray[itemCom.x - 1][itemCom.y] ~= nil and self.GameItemArray[itemCom.x - 1][itemCom.y].colorIndex == itemCom.colorIndex then
            result[#result + 1] = self.GameItemArray[itemCom.x - 1][itemCom.y]
            self:GetItemRowsLeft(result, self.GameItemArray[itemCom.x - 1][itemCom.y])
        end
    end
end

--一行向右
function GameLogic:GetItemRowsRight(result, itemCom)
    if itemCom ~= nil then
        if self.GameItemArray[itemCom.x + 1] ~= nil and self.GameItemArray[itemCom.x + 1][itemCom.y] ~= nil and self.GameItemArray[itemCom.x + 1][itemCom.y].colorIndex == itemCom.colorIndex then
            result[#result + 1] = self.GameItemArray[itemCom.x + 1][itemCom.y]
            self:GetItemRowsRight(result, self.GameItemArray[itemCom.x + 1][itemCom.y])
        end
    end
end


--检测是否是死图
function GameLogic:CheckIsDeadMap()
    local result = true
    for x = -4, 4, 1 do
        for y = 4, -4, -1 do
            local temp = self:CheckItemCanThree(self.GameItemArray[x][y])
            if #temp > 1 then
                result = false
                break
            end
        end
    end
    log(tostring(result) .. '...............................')
    return result
end

--检测一个item是否可以消除，返回可以被含有他消除的所有集合{{item1,item2,item3}，{item1,item2,item3}}
function GameLogic:CheckItemCanThree(itemCom)
    local leftTop = nil
    if self.GameItemArray[itemCom.x - 1] ~= nil then
        leftTop = self.GameItemArray[itemCom.x - 1][itemCom.y + 1]
    end

    local top = nil
    if self.GameItemArray[itemCom.x] ~= nil then
        top = self.GameItemArray[itemCom.x][itemCom.y + 1]
    end

    local rightTop = nil
    if self.GameItemArray[itemCom.x + 1] ~= nil then
        rightTop = self.GameItemArray[itemCom.x + 1][itemCom.y + 1]
    end

    local left = nil
    if self.GameItemArray[itemCom.x - 1] ~= nil then
        left = self.GameItemArray[itemCom.x - 1][itemCom.y]
    end

    local right = nil
    if self.GameItemArray[itemCom.x + 1] ~= nil then
        right = self.GameItemArray[itemCom.x + 1][itemCom.y]
    end

    local leftBottom = nil
    if self.GameItemArray[itemCom.x - 1] ~= nil then
        leftBottom = self.GameItemArray[itemCom.x - 1][itemCom.y - 1]
    end

    local bottom = nil
    if self.GameItemArray[itemCom.x] ~= nil then
        bottom = self.GameItemArray[itemCom.x][itemCom.y - 1]
    end

    local rightBottom = nil
    if self.GameItemArray[itemCom.x + 1] ~= nil then
        rightBottom = self.GameItemArray[itemCom.x + 1][itemCom.y - 1]
    end

    local result = {}

    --最上面那一行
    if leftTop ~= nil and rightTop ~= nil and leftTop.colorIndex == itemCom.colorIndex and rightTop.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { leftTop, itemCom, rightTop }
    end

    --中间那一行
    if left ~= nil and right ~= nil and left.colorIndex == itemCom.colorIndex and right.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { left, itemCom, right }
    end

    --下面那一行
    if leftBottom ~= nil and rightBottom ~= nil and leftBottom.colorIndex == itemCom.colorIndex and rightBottom.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { leftBottom, itemCom, rightBottom }
    end

    --最左边那一列
    if leftTop ~= nil and leftBottom ~= nil and leftTop.colorIndex == itemCom.colorIndex and leftBottom.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { leftTop, itemCom, leftBottom }
    end

    --中间那一列
    if top ~= nil and bottom ~= nil and top.colorIndex == itemCom.colorIndex and bottom.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { top, itemCom, bottom }
    end

    --最右边那一列
    if rightTop ~= nil and rightBottom ~= nil and rightTop.colorIndex == itemCom.colorIndex and rightBottom.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { rightTop, itemCom, rightBottom }
    end

    --中间一列连续两个
    if leftTop ~= nil and bottom ~= nil and leftTop.colorIndex == itemCom.colorIndex and bottom.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { leftTop, itemCom, bottom }
    end

    if rightTop ~= nil and bottom ~= nil and rightTop.colorIndex == itemCom.colorIndex and bottom.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { rightTop, itemCom, bottom }
    end

    if leftBottom ~= nil and top ~= nil and leftBottom.colorIndex == itemCom.colorIndex and top.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { leftBottom, itemCom, top }
    end

    if rightBottom ~= nil and top ~= nil and rightBottom.colorIndex == itemCom.colorIndex and top.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { rightBottom, itemCom, top }
    end

    --中间一行连续两个
    if leftTop ~= nil and right ~= nil and leftTop.colorIndex == itemCom.colorIndex and right.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { leftTop, itemCom, right }
    end

    if leftBottom ~= nil and right ~= nil and leftBottom.colorIndex == itemCom.colorIndex and right.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { leftBottom, itemCom, right }
    end

    if rightTop ~= nil and left ~= nil and rightTop.colorIndex == itemCom.colorIndex and left.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { rightTop, itemCom, left }
    end

    if rightBottom ~= nil and left ~= nil and rightBottom.colorIndex == itemCom.colorIndex and left.colorIndex == itemCom.colorIndex then
        result[#result + 1] = { rightBottom, itemCom, left }
    end

    return result
end

return GameLogic